<!DOCTYPE html>

<html lang="en">

	<head>
		<title>Rawkets | A massively multiplayer game built using HTML5 canvas and WebSockets</title>
		
		<meta charset="utf-8">
		<meta name="description" content="Rawkets is a massively multiplayer game in which you can shoot and interact with other players, in real-time, in space! It uses the latest Web technologies, including HTML5 canvas and WebSockets.">
		
		<link rel="stylesheet" href="style/reset.css">
		<link rel="stylesheet" href="style/rawkets_fonts.css">
		<link rel="stylesheet" href="style/rawkets.css">
	</head>
	
	<body>
		<canvas id="canvas" width="400" height="400"></canvas>
		<div id="overlay">
			<header id="header">
				<h1>Rawkets</h1>
				<nav>
					<ul id="tabs">
						<li><a id="tabGame" class="active" href="#"><span class="label">Game</span></a></li>
						<li><a id="tabSettings" href="#"><span class="label">Settings</span></a></li>
						<li><a id="tabAbout" href="#"><span class="label">About</span></a></li>
					</ul>
				</nav>
			</header>
		
			<section id="intro">
				<p>A massively multiplayer game built using HTML5 canvas and WebSockets</p>
				<p>
					<form id="play" action="">
						<input type="text" id="username" tabindex="1" placeholder="Username">
						<input type="submit" id="join" value="Join the battle">
					</form>
				</p>
			</section>
			
			<section id="settings">
				<h1>Settings</h1>
				<p>Change your settings here…</p>
			</section>
			
			<section id="about">
				<h1>About Rawkets</h1>
				<p>Rawkets is…</p>
			</section>
		
			<footer id="statistics">
				<p id="killedBy"></p>
				<p id="score">0</p>
				<p id="playerCount">0 fighters online</p>
				<p id="updates"><a href="#">Send me development updates</a></p>
			</footer>
		</div>
		
		<div id="soundContainer"></div>
		
		<script type="text/javascript" src="js/jquery.min.js"></script>
		<script type="text/javascript" src="js/jquery.xcolor.js"></script>
		<script type="text/javascript" src="js/swfobject/swfobject.js"></script>
		<script type="text/javascript" src="js/socket.io.min.js"></script>
		<script type="text/javascript" src="js/bison.js"></script>
		
		<script type="text/javascript">
			// TODO
			// Add ability to have default options for game objects and functions
			
			// Only using jQuery for website UI, not core game logic
			$("#tabs a").css({textIndent: 0}).each(function() {
				var span = $(this).find("span");
				var spanWidth = span.outerWidth();
				var tabWidth = $(this).outerWidth();
				var tabEdge = $(this).offset().left+tabWidth;
				var overEdge = (tabEdge+(spanWidth/2) < window.innerWidth) ? false : true;
				var offset = (!overEdge) ? Math.floor((tabWidth/2)-(spanWidth/2)) : 10;
				span.css({right: offset});
				
				var anchor = $("<span class='anchor'></span>");
				var anchorClass = (overEdge) ? "right" : "";
				anchor.addClass(anchorClass);
				span.append(anchor);
			}).mouseover(function() {
				var span = $(this).find("span");
				//var offset = span.
				span.toggle();
			}).mouseout(function() {
				var span = $(this).find("span");
				span.toggle();
			});
			
			//$("#username").focus();
			$("#play").submit(function(e) {
				e.preventDefault();
				var username = $("#username").val();
				//console.log(username, username.match(/^[\d\w]*$/));
				if (username != "" && username.match(/^[\d\w]*$/)) {
					$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0)"});
					$("#intro").stop().fadeOut();
					connect(username);
				};
			});
			
			$("#tabGame").click(function() {
				$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0)"});
				$("#intro, #settings, #about").hide();
				$("#tabSettings, #tabAbout").removeClass("active");
				$(this).addClass("active");
			});
			
			$("#tabSettings").click(function() {
				$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0.5)"});
				$("#intro, #about").hide();
				$("#tabSettings, #tabGame").removeClass("active");
				$(this).addClass("active");
				$("#settings").fadeIn();
			});
			
			$("#tabAbout").click(function() {
				$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0.5)"});
				$("#intro, #settings").hide();
				$("#tabGame, #tabSettings").removeClass("active");
				$(this).addClass("active");
				$("#about").fadeIn();
			});
			
			// TESTING - REMOVE THIS
			var canvas = document.getElementById("canvas");
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight-111;
			var ctx = canvas.getContext("2d");
			var score = document.getElementById("score");
			var playerCount = document.getElementById("playerCount");
			var killedBy = document.getElementById("killedBy");
			// TESTING - REMOVE THIS
			
			// Funky Object clone method
			/*Object.prototype.clone = function() {
				var newObj = (this instanceof Array) ? [] : {};

				for (i in this) {
					if (i == "clone") continue;

					if (this[i] && typeof this[i] == "object") {
						newObj[i] = this[i].clone();
					} else {
						newObj[i] = this[i];
					};
				};

				return newObj;
			};*/
			function clone(obj) {
			    if (null == obj || "object" != typeof obj) return obj;

			    // Handle Array
			    if (obj instanceof Array) {
			        var copy = [], i, len = obj.length;
			        for (i = 0; i < len; ++i) {
			            copy[i] = clone(obj[i]);
			        }
			        return copy;
			    };

			    // Handle Object
			    if (obj instanceof Object) {
			        var copy = {};
			        for (var attr in obj) {
			            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
			        }
			        return copy;
			    };

			    throw new Error("Unable to copy obj! Its type isn't supported.");
			};
			
			// Netgraph
			var NetGraph = function() {
				var width = 300,
					height = 50,
					maxPing = 200,
					maxData = 60000,
					pings = [],
					tmpData = [],
					data = [],
					packetsPerSecond = 0,
					bytesPerSecond = 0; // This is actuallt characters per second, not bytes
				
				var addPing = function(ping) {
					if (pings.length == 150) {
						pings.shift(); // Remove first ping
					};
					
					pings.push(ping);
				};
				
				var addTmpData = function(value) {
					tmpData.push(value);
				};
				
				var addData = function() {
					if (data.length == 150) {
						data.shift(); // Remove first data
					};
					
					var d, tmpDataCount = tmpData.length, value = 0;
					for (d = 0; d < tmpDataCount; d++) {
						value += tmpData[d];
					};
					
					packetsPerSecond = tmpData.length;
					bytesPerSecond = value;
					tmpData = [];
					
					data.push(value);
				};
				
				var draw = function(ctx) {
					ctx.save();
					ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
					ctx.fillRect(0, 0, width, height);
					
					ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
					ctx.font = "Bold 8px Verdana";
					ctx.fillText("0ms", width+4, height-2);
					ctx.fillText(maxPing+"ms", width+4, 10);
					
					var ms = (pings.length > 0) ? pings[pings.length-1] : 0;
					ctx.fillStyle = "rgb(255, 255, 255)";
					ctx.fillText(ms+"ms", 4, 10);
					
					ctx.fillText(packetsPerSecond+" p/s", 4, 25);
					ctx.fillText(bytesPerSecond+" b/s", 4, 40);
					
					var d, dx, dy, dat, dataCount = data.length;
					if (dataCount > 0) {
						ctx.strokeStyle = "rgb(0, 255, 0)";
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(width-(dataCount*2), height-(data[0]/(maxData/height)));
						for (d = 0; d < dataCount; d++) {
							dat = data[d];
							dx = (width-(dataCount*2))+(d*2);
							dy = height-(dat/(maxData/height));

							ctx.lineTo(dx, dy);
						};
						ctx.stroke();
					};
					
					var p, px, py, ping, pingCount = pings.length;
					if (pingCount > 0) {
						ctx.strokeStyle = "rgb(255, 255, 255)";
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(width-(pingCount*2), height-(pings[0]/(maxPing/height)));
						for (p = 0; p < pingCount; p++) {
							ping = pings[p];
							px = (width-(pingCount*2))+(p*2);
							py = height-(ping/(maxPing/height));

							ctx.lineTo(px, py);
						};
						ctx.stroke();
					};
					
					ctx.restore();
				};
				
				return {
					addPing: addPing,
					addTmpData: addTmpData,
					addData: addData,
					draw: draw
				}
			};
			
			// Vector object
			var Vector = function(opts) {
				// Public variables
				var x = opts.x || 0,
					y = opts.y || 0;

				return {
					x: x,
					y: y
				};
			};

			// Player state object
			var PlayerState = function(opts) {
				// Public variables
				var currentKeys = {left: false, right: false, up: false, down: false, space: false},
					previousKeys = clone(currentKeys),
					activeKeys = clone(currentKeys),
					pos = new Vector({x: opts.x, y: opts.y}),
					angle = opts.angle,
					moving = false,
					health = 100;
					
				var updateKeys = function() {
					//previousKeys = currentKeys.clone(); // Clone isn't working for some reason
					previousKeys.left = currentKeys.left;
					previousKeys.right = currentKeys.right;
					previousKeys.up = currentKeys.up;
					previousKeys.down = currentKeys.down;
					previousKeys.space = currentKeys.space;
					
					currentKeys.left = activeKeys.left;
					currentKeys.right = activeKeys.right;
					currentKeys.up = activeKeys.up;
					currentKeys.down = activeKeys.down;
					currentKeys.space = activeKeys.space;
				};

				return {
					pos: pos,
					angle: angle,
					moving: moving,
					currentKeys: currentKeys,
					previousKeys: previousKeys,
					activeKeys: activeKeys,
					updateKeys: updateKeys,
					health: health
				};
			};
			
			// Player object
			var Player = function(opts) {
				// Public variables
				var id = opts.id,
					username = opts.username,
					local = opts.local,
					currentState = new PlayerState({x: opts.x, y: opts.y, angle: opts.angle}),
					previousState = clone(currentState),
					colour = {c: opts.colour};

				// Public methods
				/*var update = function(dtdt) {
					// Update previous state
					previousState = currentState.clone();

					// Do stuff depending on what keys are currently pressed down
					if (currentState.keys.up) {
						currentState.acc.x += 10;
					} else {
						currentState.acc.x = 0;
					};

					// Verlet integration (http://www.gotoandplay.it/_articles/2005/08/advCharPhysics.php)
					currentState.pos.x = 2 * currentState.pos.x - previousState.pos.x + currentState.acc.x * dtdt;
					currentState.pos.y = 2 * currentState.pos.y - previousState.pos.y + currentState.acc.y * dtdt;
				};*/
				
				var draw = function(ctx) {
					var pos = (local) ? new Vector({x: canvas.width/2, y: canvas.height/2}) : viewport.worldToScreen(currentState.pos.x, currentState.pos.y);
					//console.log(currentState.pos.x);
					if (pos) { // TEMPORARY FIX. NOT IDEAL! It seems the pos variable gets screwed up every so often. Due to the check above?
						ctx.save();
						ctx.translate(pos.x, pos.y); // ERROR HERE "Uncaught TypeError: Cannot read property 'x' of undefined"
						
						// Health ring
						ctx.save();
						
						ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
						ctx.lineWidth = 10;
						ctx.beginPath();
						ctx.arc(0, 0, 40, 0, Math.PI*2, false);
						ctx.closePath();
						ctx.stroke();
						
						ctx.rotate(-Math.PI/2);
						ctx.strokeStyle = "hsla("+120*(currentState.health/100)+", 100%, 50%, 0.1)";
						ctx.beginPath();
						ctx.arc(0, 0, 40, 0, -(Math.PI*2)*(currentState.health/100), true);
						ctx.stroke();
						
						ctx.restore();
						
						if (username) {
							ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
							ctx.font = "Bold 10px Verdana";
							ctx.fillText(username, 15, 3);
						};
						
						// Rotate canvas for rocket and flame
						ctx.rotate(currentState.angle);
						
						// Draw weapon reticle
						ctx.save();
						ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
						ctx.lineWidth = 4;
						ctx.beginPath();
						ctx.moveTo(35, 0);
						ctx.lineTo(45, 0);
						ctx.closePath();
						ctx.stroke();
						ctx.restore();
						
						// Draw flame
						var flameHeight;
						if (currentState.moving) {
							flameHeight = Math.floor(8+(Math.random()*4));
							ctx.fillStyle = "orange";
							ctx.beginPath();
							ctx.moveTo(-(6+flameHeight), 0);
							ctx.lineTo(-6, -2);
							ctx.lineTo(-6, 2);
							ctx.closePath();
							ctx.fill();
						};
					
						// Draw rocket
						ctx.fillStyle = (currentState.health > 0) ? "rgb(255, 255, 255)" : "rgb(150, 150, 150)";
						ctx.beginPath();
						ctx.moveTo(-7, -6);
						ctx.lineTo(7, 0);
						ctx.lineTo(-7, 6);
						ctx.closePath();
						ctx.fill();
						
						if (colour.c && currentState.health > 0) {
							// Draw decal
							ctx.fillStyle = "rgb("+colour.c+")";
							ctx.beginPath();
							ctx.arc(-3, 0, 2, 0, Math.PI*2, false);
							ctx.closePath();
							ctx.fill();
						};
					
						ctx.restore();
					};
				};

				return {
					id: id, // Should probably be made read-only
					username: username,
					//update: update,
					draw: draw,
					currentState: currentState,
					previousState: previousState,
					colour: colour
				};
			};
			
			// Bullet state object
			var BulletState = function(opts) {
				// Public variables
				var pos = new Vector({x: opts.x, y: opts.y}),
					angle = opts.angle,
					age = 0;

				return {
					pos: pos,
					age: age,
					angle: angle
				};
			};

			// Bullet object
			var Bullet = function(opts) {
				// Public variables
				var id = opts.id,
					currentState = new BulletState({x: opts.x, y: opts.y, angle: opts.angle});
					
				var update = function() {
					currentState.age++;
				};

				// Public methods
				var draw = function(ctx) {
					ctx.save();
					ctx.translate(currentState.pos.x, currentState.pos.y);
					ctx.rotate(currentState.angle);
					ctx.fillStyle = "rgb(255, 255, 0)";
					ctx.fillRect(-6, -1, 6, 2);
					ctx.restore();
				};

				return {
					id: id,
					currentState: currentState,
					update: update,
					draw: draw
				};
			};
			
			// Viewport object
			var Viewport = function(width, height) {
				var worldWidth = 2000,
					worldHeight = 2000,
					dimensions = {width: width, height: height},
					pos = new Vector({x: worldWidth/2, y: worldHeight/2}), // Centre of the world
					previousPos = clone(pos),
					flareLeftLower = [new Image(), false],
					flareLeftUpper = [new Image(), false],
					flareRightLower = [new Image(), false],
					flareRightUpper = [new Image(), false];
					
				flareLeftLower[0].src = "style/img/game_flare_left_lower.png";
				flareLeftLower[0].onload = function() {
					flareLeftLower[1] = true;
				};
				
				flareLeftUpper[0].src = "style/img/game_flare_left_upper.png";
				flareLeftUpper[0].onload = function() {
					flareLeftUpper[1] = true;
				};
				
				flareRightLower[0].src = "style/img/game_flare_right_lower.png";
				flareRightLower[0].onload = function() {
					flareRightLower[1] = true;
				};
				
				flareRightUpper[0].src = "style/img/game_flare_right_upper.png";
				flareRightUpper[0].onload = function() {
					flareRightUpper[1] = true;
				};
				
				var withinBounds = function(x, y) {
					if (x > (pos.x - dimensions.width/2)-20 && 
						x < (pos.x + dimensions.width/2)+20 &&
						y > (pos.y - dimensions.height/2)-20 &&
						y < (pos.y + dimensions.height/2)+20) {
						return true;	
					};

					return false;
				};
				
				var worldToScreen = function(x, y) {
					var screenPos = new Vector({x: 0, y: 0});

					screenPos.x = (pos.x - dimensions.width/2) - x;
					screenPos.y = (pos.y - dimensions.height/2) - y;

					screenPos.x *= -1;
					screenPos.y *= -1;

					return screenPos;
				};
				
				var worldXToScreenX = function(x) {
					var x = (pos.x - dimensions.width/2) - x;
					x *= -1;

					return x;
				};
				
				var worldYToScreenY = function(y) {
					var y = (pos.y - dimensions.height/2) - y;
					y *= -1;

					return y;
				};
				
				var draw = function(ctx) {
					ctx.strokeStyle = "rgba(200, 200, 200, 0.2)";
					ctx.lineWidth = 20;

					var drawPos = new Vector({x: 0, y: 0});
					var drawWidth = 0;
					var drawHeight = 0;

					if (0 > (pos.x - width/2)) {
						drawPos.x = worldXToScreenX(0);
					} else {
						drawPos.x = 0;
					};

					if (0 > (pos.y - height/2)) {
						drawPos.y = worldYToScreenY(0);
					} else {
						drawPos.y = 0;
					};

					if (worldWidth < (pos.x + dimensions.width/2)) {
						drawWidth = worldXToScreenX(worldWidth)-drawPos.x;
					} else {
						drawWidth = dimensions.width;
					};

					if (worldHeight < (pos.y + dimensions.height/2)) {
						drawHeight = worldYToScreenY(worldHeight)-drawPos.y;
					} else {
						drawHeight = dimensions.height;
					};

					ctx.strokeRect(drawPos.x-ctx.lineWidth, drawPos.y-ctx.lineWidth, drawWidth+(ctx.lineWidth*2), drawHeight+(ctx.lineWidth*2));
					
					// Draw lens flares
					var flarePos = new Vector({x: 0, y: 0});
					if (flareLeftLower[1]) {
						flarePos.x = 0-((pos.x/worldWidth)*294);
						flarePos.y = dimensions.height-123-((pos.y/worldHeight)*150);
						ctx.drawImage(flareLeftLower[0], flarePos.x, flarePos.y);
					};
					
					if (flareLeftUpper[1]) {
						flarePos.x = 0-((pos.x/worldWidth)*379);
						flarePos.y = 30+((pos.y/worldHeight)*250);
						ctx.drawImage(flareLeftUpper[0], flarePos.x, flarePos.y);
					};
					
					if (flareRightLower[1]) {
						flarePos.x = dimensions.width-((pos.x/worldWidth)*380);
						flarePos.y = dimensions.height-193-((pos.y/worldHeight)*150);
						ctx.drawImage(flareRightLower[0], flarePos.x, flarePos.y);
					};
					
					if (flareRightUpper[1]) {
						flarePos.x = dimensions.width-((pos.x/worldWidth)*317);
						flarePos.y = 10+((pos.y/worldHeight)*150);
						ctx.drawImage(flareRightUpper[0], flarePos.x, flarePos.y);
					};
				};
				
				return {
					pos: pos,
					dimensions: dimensions,
					previousPos: previousPos,
					withinBounds: withinBounds,
					worldToScreen: worldToScreen,
					draw: draw
				};
			};
			
			// Star class
			var Star = function(x, y) {
				var pos = new Vector({x: x, y: y}),
					z = Math.random()*0.3;
				
				var update = function(movementDelta) {
					pos.x -= movementDelta.x*(z+0.3);
					pos.y -= movementDelta.y*(z+0.3);
				};
				
				var draw = function(ctx) {
					ctx.fillStyle = "rgba(255, 255, 255, "+(0.4+(z*0.3))+")";
					ctx.beginPath();
					ctx.arc(pos.x, pos.y, (z*10), 0, Math.PI*2, false);
					ctx.closePath();
					ctx.fill();
				};
				
				return {
					pos: pos,
					update: update,
					draw: draw
				};
			};
			
			function createStars() {
				stars = [];
				starsOriginalWidth = canvas.width;
				starsOriginalHeight = canvas.height;
				var s;
				for (s = 0; s < 20; s++) {
					stars.push(new Star(Math.random()*canvas.width, Math.random()*canvas.height));
				};
			};
			
			// Sound class
			var Sound = function() {
				var container = document.getElementById("soundContainer"),
					muted = true;
				
				var play = function(soundName) {
					if (!this.muted) {
						switch (soundName) {
							case "background":
								container.playBackground();
								break;
							case "thrust":
								container.playThrust();
								break;
							case "laser":
								container.playLaser();
								break;
							case "respawn":
								container.playRespawn();
								break;
							case "die":
								container.playDie();
								break;
						};
					};
				};

				var stop = function(soundName) {
					if (!this.muted) {
						switch (soundName) {
							case "background":
								container.stopBackground();
								break;
							case "thrust":
								container.stopThrust();
								break;
						};
					};
				};
				
				var mute = function() {
					stop("background");
					stop("thrust");
					this.muted = true;
				};
				
				var unmute = function() {
					this.muted = false;
					play("background");
				};
				
				return {
					play: play,
					stop: stop,
					muted: muted,
					mute: mute,
					unmute: unmute
				};
			};
			
			// Message formatter helper
			function formatMessage(type, args) {
				var msg = {z: type};

				for (var arg in args) {
					// Don't overwrite the message type
					if (arg != "z")
						msg[arg] = args[arg];
				};

				//return JSON.stringify(msg);
				return BISON.encode(msg);
			};
			
			// Add remote player
			function addRemotePlayer(opts) {
				var id = opts.id,
					username = opts.username,
					state = opts.state,
					colour = opts.colour,
					localPos,
					player;
				
				player = new Player({id: id, local: false, x: 0, y: 0, angle: 0, colour: colour, username: username});
				
				//localPos = viewport.worldToScreen(state.pos.x, state.pos.y);
				
				player.currentState.pos = state.pos;
				player.currentState.angle = state.angle;
				//player.currentState.currentKeys = state.keys;
				
				remotePlayers.push(player);
				console.log("Add player: ", id);
			};
			
			// Update player count
			function updatePlayerCount() {
				var plural = "";
				if (remotePlayers.length > 0) {
					plural = "s";
				};
				playerCount.innerHTML = (remotePlayers.length+1)+" fighter"+plural+" online";
			};
			
			// Find player by ID
			function playerById(id) {
				for (var i = 0; i < remotePlayers.length; i++) {
					if (remotePlayers[i].id == id)
						return remotePlayers[i];
				};

				return false;
			};

			// Find player index by ID
			function indexOfByPlayerId(id) {
				for (var i = 0; i < remotePlayers.length; i++) {
					if (remotePlayers[i].id == id) {
						return i;
					};
				};

				return false;
			};
			
			// Find bullet by ID
			function bulletById(id) {
				for (var i = 0; i < bullets.length; i++) {
					if (bullets[i].id == id)
						return bullets[i];
				};

				return false;
			};

			// Find bullet index by ID
			function indexOfByBulletId(id) {
				for (var i = 0; i < bullets.length; i++) {
					if (bullets[i].id == id) {
						return i;
					};
				};

				return false;
			};
			
			// Event listeners
			window.addEventListener("keydown", onKeydown, false);
			window.addEventListener("keyup", onKeyup, false);
			window.addEventListener("resize", resizeCanvas, false);
			
			function onKeydown(e) {
				var c = e.keyCode;
				
				if (localPlayer) {
					switch (c) {
						// Controls
						case 32: // Space
							localPlayer.currentState.activeKeys.space = true;
							break;
						case 37: // Left
							localPlayer.currentState.activeKeys.left = true;
							break;
						case 38: // Up
							localPlayer.currentState.activeKeys.up = true;
							break;
						case 39: // Right
							localPlayer.currentState.activeKeys.right = true;
							break;
						case 40: // Down
							localPlayer.currentState.activeKeys.down = true;
							break;
						case 83: // S
							if (sound.muted) {
								sound.unmute();
							} else {
								sound.mute();
							};
							break;
					};
				};

				//console.log("Key down [code: "+e.keyCode+"]");
			};
			
			function onKeyup(e) {
				var c = e.keyCode;

				if (localPlayer) {
					switch (c) {
						case 32: // Space
							localPlayer.currentState.activeKeys.space = false;
							break;
						case 37: // Left
							localPlayer.currentState.activeKeys.left = false;
							break;
						case 38: // Up
							localPlayer.currentState.activeKeys.up = false;
							break;
						case 39: // Right
							localPlayer.currentState.activeKeys.right = false;
							break;
						case 40: // Down
							localPlayer.currentState.activeKeys.down = false;
							break;
					};
				};

				//console.log("Key down [code: "+e.keyCode+"]");
			};
			
			function resizeCanvas(e) {
				// Horrible passing of game object due to event closure
				//var self = (e != null) ? e.data.self : this;

				//var height = $(window).height();
				//var width = $(window).width()

				//self.canvas.attr({height: height, width: width});
				
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight-111; // Minus footer and header

				if (viewport != undefined) {
					viewport.dimensions.width = canvas.width;
					viewport.dimensions.height = canvas.height;
				};

				if (stars != undefined) {
					var xRatio = canvas.width/starsOriginalWidth;
					var yRatio = canvas.height/starsOriginalHeight;

					var starCount = stars.length,
						star,
						s;
					for (s = 0; s < starCount; s++) {
						star = stars[s];

						if (star == null) {
							continue;
						};

						star.pos.x *= xRatio;
						star.pos.y *= yRatio;
					};

					starsOriginalWidth = canvas.width;
					starsOriginalHeight = canvas.height;
				};
				
				var msg = formatMessage(MESSAGE_TYPE_UPDATE_PLAYER_SCREEN, {
					w: viewport.dimensions.width+50,
					h: viewport.dimensions.height+50
				});
				socket.send(msg);
			};
			
			// Connect to game
			function connect(username) {
				if (username.match(/^[\d\w]*$/)) {
					localPlayerUsername = username;
					// Connect to WebSocket server
					socket.connect();
				};
			};
			
			// Message types
			var MESSAGE_TYPE_UPDATE_REMOTE_PLAYER_STATE = 0,
				MESSAGE_TYPE_NEW_PLAYER = 1,
				MESSAGE_TYPE_REMOVE_PLAYER = 2,
				MESSAGE_TYPE_ENABLE_PLAYER_KEY = 3,
				MESSAGE_TYPE_DISABLE_PLAYER_KEY = 4,
				MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_POSITION = 5,
				MESSAGE_TYPE_PING = 6,
				MESSAGE_TYPE_NEW_BULLET = 7,
				MESSAGE_TYPE_UPDATE_BULLET_STATE = 8,
				MESSAGE_TYPE_REMOVE_BULLET = 9,
				MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_COLOUR = 10,
				MESSAGE_TYPE_UPDATE_PLAYER_SCREEN = 11,
				MESSAGE_TYPE_KILLED_BY = 12,
				MESSAGE_TYPE_UPDATE_SCORE = 13,
			
			// Run game
				runUpdate = true,
			
			// Socket settings
				WEB_SOCKET_SWF_LOCATION = "lib/WebSocketMain.swf",
				//socketHost = "194.110.243.147",
				socketHost = "localhost",
				socket = new io.Socket(socketHost, {port: 8000, transports: ["websocket", "flashsocket"]}),
				
			// Netgraph
				net = new NetGraph(),
				
			// Game world
				viewport = new Viewport(canvas.width, canvas.height),
				stars = [],
				starsOriginalWidth = canvas.width,
				starsOriginalHeight = canvas.height,
			
			// Players	
				localPlayer,
				localPlayerUsername,
				remotePlayers = [],
				
			// Weapons
				bullets = [],
				
			// Sound setup
				sound,
				flashvars = {},
				params = {allowscriptaccess: "always"};
			
			swfobject.embedSWF("lib/Sounds.swf", "soundContainer", "0", "0", "9.0.0", "", flashvars, params, "", function(err) {
				sound = new Sound();
				
				// Unneccesary delay to let sound load
				setTimeout(function() {
					// Play background
					sound.play("background");
				}, 2000);
			});
			
			// Set up stars
			createStars();
			
			// EVENTS
			// connect, connecting, connect_failed, message, close,
			// disconnect, reconnect, reconnecting, reconnect_failed
			
			// WebSocket connection successful
			socket.on("connect", function(){
				console.log("Connected");
				localPlayer = new Player({id: false, local: true, x: 1000, y: 1000, angle: 0, colour: false, username: localPlayerUsername});
				// Move to message queuing system
				var msg = formatMessage(MESSAGE_TYPE_NEW_PLAYER, {u: localPlayerUsername, w: viewport.dimensions.width+50, h: viewport.dimensions.height+50, s: localPlayer.currentState});
				socket.send(msg);
			
				updatePlayerCount();
			});
		
			// WebSocket connection failed
			socket.on("connect_failed", function() {
				console.log("Connect failed");
			});
		
			// WebSocket disconnection
			socket.on("disconnect", function() {
				console.log("Disconnected");
			});
		
			// WebSocket message received
			socket.on("message", function(data){
				var msg = BISON.decode(data);
				//console.log("Message received: ", msg);
			
				net.addTmpData(data.length);
			
				// Move this to a dedicate message queuing system
				if (msg.z !== undefined) {
					switch (msg.z) {
						case MESSAGE_TYPE_PING:
							if (msg.t) {
								socket.send(formatMessage(MESSAGE_TYPE_PING, {t: msg.t}));
							};

							if (msg.p) {
								net.addPing(msg.p);
								net.addData();
							};
							break;
						case MESSAGE_TYPE_NEW_PLAYER:
							var colour = (msg.c) ? msg.c : false;
							addRemotePlayer({id: msg.id, state: msg.s, colour: colour, username: msg.u});
							updatePlayerCount();
							break;
						case MESSAGE_TYPE_REMOVE_PLAYER:
							var player = playerById(msg.id);
							if (player) {
								console.log("Remove player: ", msg.id);
								remotePlayers.splice(indexOfByPlayerId(msg.id), 1);
							};
							updatePlayerCount();
							break;
						case MESSAGE_TYPE_UPDATE_REMOTE_PLAYER_STATE:
							//console.log(msg);
							var player = playerById(msg.id),
								localPos;
							if (player) {
								//console.log("Player state: ", player.currentState);
								// THIS IS BAD – CHANGE TO PREDICTIVE METHOD
								//player.currentState.pos.x = msg.state.pos.x;
								//console.log(player.currentState.pos.x);
								//localPos = viewport.worldToScreen(msg.state.pos.x, msg.state.pos.y);
							
								// Only update position (must be off screen)
								if (msg.a == undefined) {
									if (msg.p != undefined) {
										player.previousState.pos = player.currentState.pos;
										player.currentState.pos = msg.p;
									};
									if (msg.h != undefined) {
										player.previousState.health = player.currentState.health;
										player.currentState.health = msg.h;
									};
									break;
								};
							
								player.previousState.pos = player.currentState.pos;
								player.previousState.angle = player.currentState.angle;
								player.previousState.moving = player.currentState.moving;
								//player.previousState.currentKeys = player.currentState.keys;
								player.previousState.health = player.currentState.health;
								
								if (msg.p != undefined) {
									player.currentState.pos = msg.p;
								};
								if (msg.a != undefined) {
									player.currentState.angle = msg.a;
								};
								if (msg.m != undefined) {
									player.currentState.moving = msg.m;
								};
								if (msg.h != undefined) {
									player.currentState.health = msg.h;
								};
							
								if (player.previousState.health - player.currentState.health > 30 || player.currentState.health <= 0) {
									sound.play("die");
								};
							
								if (msg.a != undefined && player.previousState.health <= 0 && player.currentState.health >= 90) {
									sound.play("respawn");
								};
							};
							break;
						case MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_POSITION:
							if (localPlayer) {
								localPlayer.previousState.angle = localPlayer.currentState.angle;
								localPlayer.previousState.moving = localPlayer.currentState.moving;
								localPlayer.previousState.health = localPlayer.currentState.health;
								
								if (msg.a != undefined) {
									localPlayer.currentState.angle = msg.a;
								};
								if (msg.m != undefined) {
									localPlayer.currentState.moving = msg.m;
								};
								if (msg.h != undefined) {
									localPlayer.currentState.health = msg.h;
								};
							
								viewport.previousPos.x = viewport.pos.x;
								viewport.previousPos.y = viewport.pos.y;
								if (msg.p != undefined) {
									viewport.pos.x = msg.p.x;
									viewport.pos.y = msg.p.y;
								};
							
								if (localPlayer.previousState.health - localPlayer.currentState.health > 30 || localPlayer.currentState.health <= 0) {
									sound.play("die");
								};
							
								if (localPlayer.previousState.health <= 0 && localPlayer.currentState.health >= 90) {
									viewport.previousPos.x = viewport.pos.x;
									viewport.previousPos.y = viewport.pos.y;
								
									// Set up stars
									createStars();
								
									sound.play("respawn");
								};
							};
							break;
						case MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_COLOUR:
							if (localPlayer) {
								localPlayer.colour.c = msg.c;
							};
							break;
						case MESSAGE_TYPE_NEW_BULLET:
							var bullet, localpos;
							localPos = viewport.worldToScreen(msg.x, msg.y);
							bullet = new Bullet({id: msg.id, x: localPos.x, y: localPos.y, angle: msg.a});
							bullets.push(bullet);
							sound.play("laser");
							break;
						case MESSAGE_TYPE_UPDATE_BULLET_STATE:
							var incBullets = msg.b, bullet, localPos, b, bulletCount = bullets.length;

							for (b = 0; b < bulletCount; b++) {
								if (incBullets[b] == undefined) {
									continue;
								};
								
								bullet = bulletById(incBullets[b].id);
								if (bullet) {
									localPos = viewport.worldToScreen(incBullets[b].x, incBullets[b].y);
									bullet.currentState.pos.x = localPos.x;
									bullet.currentState.pos.y = localPos.y;
								};
							};
							break;
						case MESSAGE_TYPE_REMOVE_BULLET:
							//console.log("Remove bullet", msg.id);
							var bullet = bulletById(msg.id);
							if (bullet) {
								//console.log("Successful", bullet.id);
								//bullet.currentState.alive = false;
								bullets.splice(indexOfByBulletId(msg.id), 1);
							};
							break;
						case MESSAGE_TYPE_KILLED_BY:
							var player = playerById(msg.id);
							if (player) {
								killedBy.innerHTML = player.username+" just killed you";
								setTimeout(function() {
									killedBy.innerHTML = "";
								}, 5000);
							};
							break;
						case MESSAGE_TYPE_UPDATE_SCORE:
							score.innerHTML = msg.s;
							break;
					};
				};
			
				//var state = BISON.decode(data);
				//ctx.clearRect(0, 0, canvas.width, canvas.height);
				//ctx.fillRect(state.pos.x, 100, 5, 5);
			});
			
			// Main update loop
			function update() {
				if (localPlayer != null) {
					localPlayer.currentState.updateKeys();
				};
					
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				viewport.draw(ctx);
				
				var playerMoveDelta = new Vector({x: viewport.pos.x-viewport.previousPos.x, y: viewport.pos.y-viewport.previousPos.y}),
				//var playerMoveDelta = new Vector({x: 0, y: 0}),
					starCount = stars.length,
					star,
					s;
					
				// This is a resource hog
				for (s = 0; s < starCount; s++) {
					star = stars[s];

					if (!star || star == null) {
						continue;
					};
					
					if (Math.abs(playerMoveDelta.x) > 0.5 || Math.abs(playerMoveDelta.y) > 0.5) {
						//console.log(Math.abs(playerMoveDelta.x), Math.abs(playerMoveDelta.y));
						star.update(playerMoveDelta);

						// Wrap stars around screen
						star.pos.x = (star.pos.x < 0) ? canvas.width : star.pos.x;
						star.pos.x = (star.pos.x > canvas.width) ? 0 : star.pos.x;
						star.pos.y = (star.pos.y < 0) ? canvas.height : star.pos.y;
						star.pos.y = (star.pos.y > canvas.height) ? 0 : star.pos.y;
					};
					
					star.draw(ctx);
				};
				
				var b, bullet, deadBullets = [], bulletCount = bullets.length;
				if (bulletCount > 0) {
					for (b = 0; b < bulletCount; b++) {
						bullet = bullets[b];
						if (bullet) {
							bullet.update();
							
							if (bullet.currentState.age < 75) {
								bullet.draw(ctx);
							} else {
								deadBullets.push(bullet);
							};
						};
					};
				};
				
				// Remove dead bullets
				var db, bulletIndex, deadBulletCount = deadBullets.length;
				for (db = 0; db < deadBulletCount; db++) {
					bullet = deadBullets[db];
					bulletIndex = indexOfByBulletId(deadBullets[db].id);

					if (bullet) {
						bullets.splice(bulletIndex, 1);
					};
				};
				
				var i, player, playerCount = remotePlayers.length;
				if (playerCount > 0) {
					for (i = 0; i < playerCount; i++) {
						player = remotePlayers[i];
						//console.log(player.currentState.pos.x);
						if (player) {
							if (viewport.withinBounds(player.currentState.pos.x, player.currentState.pos.y)) {
								player.draw(ctx);
							// Player is outside of the viewport
							} else {
								// Draw an arrow at the edge of the viewport indicating where the player is
								var localScreenPos = viewport.worldToScreen(viewport.pos.x, viewport.pos.y);
								var screenPos = viewport.worldToScreen(player.currentState.pos.x, player.currentState.pos.y);

								var x1 = localScreenPos.x;
								var y1 = localScreenPos.y;
								var x2 = screenPos.x;
								var y2 = screenPos.y;
								
								var angle = Math.atan2(y1-y2, x1-x2);

								var x3;
								var y3;
								var x4;
								var y4;

								var px;
								var py;

								// Check bottom edge
								if (screenPos.y > canvas.height) {
									x3 = 0;
									y3 = canvas.height;
									x4 = canvas.width;
									y4 = canvas.height;

									// Can this formula be simplified?
									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									
									px = px;
									py -= 10;
								};

								// Check top edge
								if (screenPos.y < 0) {
									x3 = 0;
									y3 = 0;
									x4 = canvas.width;
									y4 = 0;

									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));

									px = px;
									py += 10;
									//ctx.fillStyle = "rgb(255, 0, 0)";
									//ctx.fillRect(px-2, py, 4, 4);
								};

								// Check left edge
								if (screenPos.x < 0) {
									x3 = 0;
									y3 = 0;
									x4 = 0;
									y4 = canvas.height;

									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));

									px += 10;
									py = py;
									//ctx.fillStyle = "rgb(255, 0, 0)";
									//ctx.fillRect(px, py-2, 4, 4);
								};

								// Check right edge
								if (screenPos.x > canvas.width) {
									x3 = canvas.width;
									y3 = 0;
									x4 = canvas.width;
									y4 = canvas.height;

									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									
									px -= 10;
									py = py;
									//ctx.fillStyle = "rgb(255, 0, 0)";
									//ctx.fillRect(px-4, py-2, 4, 4);
								};
								
								ctx.save();
								ctx.translate(px, py);
								ctx.rotate(angle);
								ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
								//ctx.fillRect(-2, -2, 4, 4);
								ctx.beginPath();
								ctx.moveTo(-5, 0);
								ctx.lineTo(5, 5);
								ctx.lineTo(5, -5);
								ctx.closePath();
								ctx.fill();
								ctx.restore();
							};
						};
					};
				};
				
				// Move draw functionality to another method?
				if (localPlayer != null) {
					localPlayer.draw(ctx);
				};
				
				// Move to message queuing system
				if (localPlayer != null && localPlayer.currentState.currentKeys.left && localPlayer.currentState.currentKeys.left != localPlayer.currentState.previousKeys.left) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 37});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.left && localPlayer.currentState.currentKeys.left != localPlayer.currentState.previousKeys.left) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 37});
					socket.send(msg);
				};
				
				if (localPlayer != null && localPlayer.currentState.currentKeys.up && localPlayer.currentState.currentKeys.up != localPlayer.currentState.previousKeys.up) {
					sound.play("thrust");
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 38});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.up && localPlayer.currentState.currentKeys.up != localPlayer.currentState.previousKeys.up) {
					sound.stop("thrust");
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 38});
					socket.send(msg);
				};
				
				if (localPlayer != null && localPlayer.currentState.currentKeys.right && localPlayer.currentState.currentKeys.right != localPlayer.currentState.previousKeys.right) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 39});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.right && localPlayer.currentState.currentKeys.right != localPlayer.currentState.previousKeys.right) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 39});
					socket.send(msg);
				};
				
				if (localPlayer != null && localPlayer.currentState.currentKeys.down && localPlayer.currentState.currentKeys.down != localPlayer.currentState.previousKeys.down) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 40});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.down && localPlayer.currentState.currentKeys.down != localPlayer.currentState.previousKeys.down) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 40});
					socket.send(msg);
				};
				
				// Fire weapon
				if (localPlayer != null && localPlayer.currentState.currentKeys.space && localPlayer.currentState.currentKeys.space != localPlayer.currentState.previousKeys.space) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 32});
					socket.send(msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.space && localPlayer.currentState.currentKeys.space != localPlayer.currentState.previousKeys.space) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 32});
					socket.send(msg);
				};
				
				// Draw netgraph
				net.draw(ctx);
				
				// Schedule next game update
				if (runUpdate) {
					setTimeout(update, 1000/60); // Remember, this is however long it take to update PLUS 60ms
				};
			};
			
			// Start main update loop
			update();
		</script>
	</body>
</html>